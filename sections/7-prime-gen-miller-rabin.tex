%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../index"
%%% End:

% Recommended:
% Prime generation
% Trial division
% Miller-Rabin
% - Not guaranteed correct, but chance of fault can be made small.

\subsection*{Agenda}
\begin{enumerate}
\item Prime generation
\item Trial division
\item Miller-Rabin
\end{enumerate}

\subsection{Prime Generation}
Primes can be guessed.

We have a method how to approximate number of primes in a interval.
\[ \frac{\pi (m)}{m/\ln m} \]
Here $\pi (m)$ is all primes that are less than $m$.

To generate a $k$-bit prime $m$ we use this approximation to get the
probability of finding $m$. If $m$ lies in the interval $2^{k-1}$ to
$2^k-1$ we get:
\[
\pi (2^k)-\pi (2^{k-1}) \approx
\frac{2^k}{\ln 2^k}-\frac{2^{k-1}}{\ln 2^{k-1}}
\approx \frac{2^{k-1}}{\ln 2^{k-1}}
\]
If we now chose a random m within our interval, we now know what the
probability of it being a prime is. If we exempt all even number, we
increase the probability of guessing the prime with a factor of two.

\subsection{Trial division}
Trial division is quite simple and another way to generate a k-bit prime.
\begin{itemize}
\item input an integer $m$
\item We devide $m$ with all primes $r\le \sqrt{m}$ (This is true sice if a factor is larger than $\sqrt{m}$ then it has atleast another factor that is smaller than $\sqrt{m}$)
\item if $r$ devides $m$ then $m$ isn't prime
\item if all primes $r$ are coprime with $m$ then it is prime
\end{itemize}
This requires that we have all primes under the number we want to find.

\subsection{Miller-Rabin}
Miller-Rabin is another method of determining if a number is prime or
not. It does not suffer from the weakness of rating Carmichael numbers
as primes. When checking for primes we only check odd numbers that are
greater than 2.

\subsubsection*{Setup}
\begin{itemize}
\item An odd $m$ to check if prime
\item $s$ and $t$ which are found by subtracting 1 from $m$ and
  dividing with two until result is odd. $s$ is the times we divide by
  2 and $t$ is the odd result.
\end{itemize}

\subsubsection*{Testing}
Given $m$, $s$ and $t$, we start by calculating
\[ m - 1 =2^s t \]

Now pick a random integer $b$ in the interval $0<b<m$.

\textbf{Case 1}

If $b^t \equiv 1 \mod m$ holds, we know that $m$ is prime and we are finished.

\textbf{Case 2}

We calculate
\[ b^{2^{s}t} \mod m \]

If $m$ is a prime:
\begin{align}\label{eq:miller-fac}
  &\text{With Fermat's Little Theorem} \notag\\
  &\qquad 1 = b^{m-1} \mod m \notag\\
  &\text{We inset } b^{2^st} \notag\\
  &\qquad 0 = b^{2^st}-1\mod m \notag\\
  &\text{We now expand } b^{2^{s}t} - 1 \text{ by factoring the difference between two squares} \notag\\
  &\qquad 0 = (b^{2^{s-1}t} + 1)(b^{2^{s-1}t} - 1) \mod m \notag\\
  &\text{We now expand } b^{2^{s-1}t}-1 \notag\\
  &\qquad 0 = (b^{2^{s-1}t} + 1)(b^{2^{s-2}t} + 1)(b^{2^{s-2}t} - 1) \mod m \notag\\
  &\text{We keep expanding until $s=0$ then we get $b^{2t} - 1$, and there after} \notag\\
  &\qquad 0 = (b^{2^{s-1}t} + 1)(b^{2^{s-2}t} + 1) \ldots (b^{t} + 1)(b^{t} - 1) \mod m
\end{align}

Theorem $2.4.3$ states, if $ab \equiv 0 \mod p$ then $a \equiv 0
\mod p$ or $b \equiv 0 \mod p$. So to check if $m$ is prime, the
right-hand side of the result above (\ref{eq:miller-fac}) should
result in zero.

E.g. if we pretend that $b^{2^{s-1}t} \equiv -1 \mod m$
\begin{align*}
  0 &= (-1+1)(b^{2^{s-2}t}+1)...(b^{2^t}+1)(b^{2^t} - 1) \mod m \\
  0 &= 0 \cdot (b^{2^{s-2}t}+1)...(b^{2t}+1)(b^{2t} - 1) \mod m \\
  0 &= 0 \mod m \\
\end{align*}
\begin{align*}
  &\text{Case 1}\\
  &\qquad b^t \equiv 1 \mod m\\
  &\text{Case 2}\\
  &\qquad b^{2^{j}t} \equiv -1 \mod m \text{ for at least one $j=0,\ldots,s-1$}
\end{align*}

\subsubsection*{Correctness}
Even the condition above holds for $m$, we cannot be completely sure
if $m$ really is a prime. If Miller-Rabin says that $m$ is
composite, it is. But, it can be shown that Miller-Rabin has at most
$1/4$ probability of falsely assigning a composite as a prime. This
can be countered by doing Miller-Rabin several times with different
random value $b$. This lowers the chance of the algorithm begin
wrong by $\frac{1}{4}^l$ where $l$ is the number of different values
for $b$ tested.
